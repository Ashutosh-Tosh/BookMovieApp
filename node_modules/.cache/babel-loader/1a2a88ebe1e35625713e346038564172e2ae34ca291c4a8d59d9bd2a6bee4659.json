{"ast":null,"code":"import pathToRegexp from \"path-to-regexp\";\nvar patternCache = {};\nvar cacheLimit = 10000;\nvar cacheCount = 0;\nvar compilePath = function compilePath(pattern, options) {\n  var cacheKey = \"\" + options.end + options.strict + options.sensitive;\n  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});\n  if (cache[pattern]) return cache[pattern];\n  var keys = [];\n  var re = pathToRegexp(pattern, keys, options);\n  var compiledPattern = {\n    re: re,\n    keys: keys\n  };\n  if (cacheCount < cacheLimit) {\n    cache[pattern] = compiledPattern;\n    cacheCount++;\n  }\n  return compiledPattern;\n};\n\n/**\r\n * Public API for matching a URL pathname to a path pattern.\r\n */\nvar matchPath = function matchPath(pathname) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var parent = arguments[2];\n  if (typeof options === \"string\") options = {\n    path: options\n  };\n  var _options = options,\n    path = _options.path,\n    _options$exact = _options.exact,\n    exact = _options$exact === undefined ? false : _options$exact,\n    _options$strict = _options.strict,\n    strict = _options$strict === undefined ? false : _options$strict,\n    _options$sensitive = _options.sensitive,\n    sensitive = _options$sensitive === undefined ? false : _options$sensitive;\n  if (path == null) return parent;\n  var _compilePath = compilePath(path, {\n      end: exact,\n      strict: strict,\n      sensitive: sensitive\n    }),\n    re = _compilePath.re,\n    keys = _compilePath.keys;\n  var match = re.exec(pathname);\n  if (!match) return null;\n  var url = match[0],\n    values = match.slice(1);\n  var isExact = pathname === url;\n  if (exact && !isExact) return null;\n  return {\n    path: path,\n    // the path pattern used to match\n    url: path === \"/\" && url === \"\" ? \"/\" : url,\n    // the matched portion of the URL\n    isExact: isExact,\n    // whether or not we matched exactly\n    params: keys.reduce(function (memo, key, index) {\n      memo[key.name] = values[index];\n      return memo;\n    }, {})\n  };\n};\nexport default matchPath;","map":{"version":3,"names":["pathToRegexp","patternCache","cacheLimit","cacheCount","compilePath","pattern","options","cacheKey","end","strict","sensitive","cache","keys","re","compiledPattern","matchPath","pathname","arguments","length","undefined","parent","path","_options","_options$exact","exact","_options$strict","_options$sensitive","_compilePath","match","exec","url","values","slice","isExact","params","reduce","memo","key","index","name"],"sources":["C:/Users/ashut/OneDrive/Desktop/UPGRAD/React-Project/BookMovieApp/BookMovieApp/node_modules/react-router/es/matchPath.js"],"sourcesContent":["import pathToRegexp from \"path-to-regexp\";\r\n\r\nvar patternCache = {};\r\nvar cacheLimit = 10000;\r\nvar cacheCount = 0;\r\n\r\nvar compilePath = function compilePath(pattern, options) {\r\n  var cacheKey = \"\" + options.end + options.strict + options.sensitive;\r\n  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});\r\n\r\n  if (cache[pattern]) return cache[pattern];\r\n\r\n  var keys = [];\r\n  var re = pathToRegexp(pattern, keys, options);\r\n  var compiledPattern = { re: re, keys: keys };\r\n\r\n  if (cacheCount < cacheLimit) {\r\n    cache[pattern] = compiledPattern;\r\n    cacheCount++;\r\n  }\r\n\r\n  return compiledPattern;\r\n};\r\n\r\n/**\r\n * Public API for matching a URL pathname to a path pattern.\r\n */\r\nvar matchPath = function matchPath(pathname) {\r\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n  var parent = arguments[2];\r\n\r\n  if (typeof options === \"string\") options = { path: options };\r\n\r\n  var _options = options,\r\n      path = _options.path,\r\n      _options$exact = _options.exact,\r\n      exact = _options$exact === undefined ? false : _options$exact,\r\n      _options$strict = _options.strict,\r\n      strict = _options$strict === undefined ? false : _options$strict,\r\n      _options$sensitive = _options.sensitive,\r\n      sensitive = _options$sensitive === undefined ? false : _options$sensitive;\r\n\r\n\r\n  if (path == null) return parent;\r\n\r\n  var _compilePath = compilePath(path, { end: exact, strict: strict, sensitive: sensitive }),\r\n      re = _compilePath.re,\r\n      keys = _compilePath.keys;\r\n\r\n  var match = re.exec(pathname);\r\n\r\n  if (!match) return null;\r\n\r\n  var url = match[0],\r\n      values = match.slice(1);\r\n\r\n  var isExact = pathname === url;\r\n\r\n  if (exact && !isExact) return null;\r\n\r\n  return {\r\n    path: path, // the path pattern used to match\r\n    url: path === \"/\" && url === \"\" ? \"/\" : url, // the matched portion of the URL\r\n    isExact: isExact, // whether or not we matched exactly\r\n    params: keys.reduce(function (memo, key, index) {\r\n      memo[key.name] = values[index];\r\n      return memo;\r\n    }, {})\r\n  };\r\n};\r\n\r\nexport default matchPath;"],"mappings":"AAAA,OAAOA,YAAY,MAAM,gBAAgB;AAEzC,IAAIC,YAAY,GAAG,CAAC,CAAC;AACrB,IAAIC,UAAU,GAAG,KAAK;AACtB,IAAIC,UAAU,GAAG,CAAC;AAElB,IAAIC,WAAW,GAAG,SAASA,WAAW,CAACC,OAAO,EAAEC,OAAO,EAAE;EACvD,IAAIC,QAAQ,GAAG,EAAE,GAAGD,OAAO,CAACE,GAAG,GAAGF,OAAO,CAACG,MAAM,GAAGH,OAAO,CAACI,SAAS;EACpE,IAAIC,KAAK,GAAGV,YAAY,CAACM,QAAQ,CAAC,KAAKN,YAAY,CAACM,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC;EAEnE,IAAII,KAAK,CAACN,OAAO,CAAC,EAAE,OAAOM,KAAK,CAACN,OAAO,CAAC;EAEzC,IAAIO,IAAI,GAAG,EAAE;EACb,IAAIC,EAAE,GAAGb,YAAY,CAACK,OAAO,EAAEO,IAAI,EAAEN,OAAO,CAAC;EAC7C,IAAIQ,eAAe,GAAG;IAAED,EAAE,EAAEA,EAAE;IAAED,IAAI,EAAEA;EAAK,CAAC;EAE5C,IAAIT,UAAU,GAAGD,UAAU,EAAE;IAC3BS,KAAK,CAACN,OAAO,CAAC,GAAGS,eAAe;IAChCX,UAAU,EAAE;EACd;EAEA,OAAOW,eAAe;AACxB,CAAC;;AAED;AACA;AACA;AACA,IAAIC,SAAS,GAAG,SAASA,SAAS,CAACC,QAAQ,EAAE;EAC3C,IAAIV,OAAO,GAAGW,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;EACpF,IAAIG,MAAM,GAAGH,SAAS,CAAC,CAAC,CAAC;EAEzB,IAAI,OAAOX,OAAO,KAAK,QAAQ,EAAEA,OAAO,GAAG;IAAEe,IAAI,EAAEf;EAAQ,CAAC;EAE5D,IAAIgB,QAAQ,GAAGhB,OAAO;IAClBe,IAAI,GAAGC,QAAQ,CAACD,IAAI;IACpBE,cAAc,GAAGD,QAAQ,CAACE,KAAK;IAC/BA,KAAK,GAAGD,cAAc,KAAKJ,SAAS,GAAG,KAAK,GAAGI,cAAc;IAC7DE,eAAe,GAAGH,QAAQ,CAACb,MAAM;IACjCA,MAAM,GAAGgB,eAAe,KAAKN,SAAS,GAAG,KAAK,GAAGM,eAAe;IAChEC,kBAAkB,GAAGJ,QAAQ,CAACZ,SAAS;IACvCA,SAAS,GAAGgB,kBAAkB,KAAKP,SAAS,GAAG,KAAK,GAAGO,kBAAkB;EAG7E,IAAIL,IAAI,IAAI,IAAI,EAAE,OAAOD,MAAM;EAE/B,IAAIO,YAAY,GAAGvB,WAAW,CAACiB,IAAI,EAAE;MAAEb,GAAG,EAAEgB,KAAK;MAAEf,MAAM,EAAEA,MAAM;MAAEC,SAAS,EAAEA;IAAU,CAAC,CAAC;IACtFG,EAAE,GAAGc,YAAY,CAACd,EAAE;IACpBD,IAAI,GAAGe,YAAY,CAACf,IAAI;EAE5B,IAAIgB,KAAK,GAAGf,EAAE,CAACgB,IAAI,CAACb,QAAQ,CAAC;EAE7B,IAAI,CAACY,KAAK,EAAE,OAAO,IAAI;EAEvB,IAAIE,GAAG,GAAGF,KAAK,CAAC,CAAC,CAAC;IACdG,MAAM,GAAGH,KAAK,CAACI,KAAK,CAAC,CAAC,CAAC;EAE3B,IAAIC,OAAO,GAAGjB,QAAQ,KAAKc,GAAG;EAE9B,IAAIN,KAAK,IAAI,CAACS,OAAO,EAAE,OAAO,IAAI;EAElC,OAAO;IACLZ,IAAI,EAAEA,IAAI;IAAE;IACZS,GAAG,EAAET,IAAI,KAAK,GAAG,IAAIS,GAAG,KAAK,EAAE,GAAG,GAAG,GAAGA,GAAG;IAAE;IAC7CG,OAAO,EAAEA,OAAO;IAAE;IAClBC,MAAM,EAAEtB,IAAI,CAACuB,MAAM,CAAC,UAAUC,IAAI,EAAEC,GAAG,EAAEC,KAAK,EAAE;MAC9CF,IAAI,CAACC,GAAG,CAACE,IAAI,CAAC,GAAGR,MAAM,CAACO,KAAK,CAAC;MAC9B,OAAOF,IAAI;IACb,CAAC,EAAE,CAAC,CAAC;EACP,CAAC;AACH,CAAC;AAED,eAAerB,SAAS"},"metadata":{},"sourceType":"module","externalDependencies":[]}