{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nimport warning from 'warning';\nimport invariant from 'invariant';\nimport { createLocation, locationsAreEqual } from './LocationUtils';\nimport { addLeadingSlash, stripLeadingSlash, stripTrailingSlash, hasBasename, stripBasename, createPath } from './PathUtils';\nimport createTransitionManager from './createTransitionManager';\nimport { canUseDOM, addEventListener, removeEventListener, getConfirmation, supportsGoWithoutReloadUsingHash } from './DOMUtils';\nvar HashChangeEvent = 'hashchange';\nvar HashPathCoders = {\n  hashbang: {\n    encodePath: function encodePath(path) {\n      return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);\n    },\n    decodePath: function decodePath(path) {\n      return path.charAt(0) === '!' ? path.substr(1) : path;\n    }\n  },\n  noslash: {\n    encodePath: stripLeadingSlash,\n    decodePath: addLeadingSlash\n  },\n  slash: {\n    encodePath: addLeadingSlash,\n    decodePath: addLeadingSlash\n  }\n};\nvar getHashPath = function getHashPath() {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var hashIndex = href.indexOf('#');\n  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);\n};\nvar pushHashPath = function pushHashPath(path) {\n  return window.location.hash = path;\n};\nvar replaceHashPath = function replaceHashPath(path) {\n  var hashIndex = window.location.href.indexOf('#');\n  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);\n};\nvar createHashHistory = function createHashHistory() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  invariant(canUseDOM, 'Hash history needs a DOM');\n  var globalHistory = window.history;\n  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();\n  var _props$getUserConfirm = props.getUserConfirmation,\n    getUserConfirmation = _props$getUserConfirm === undefined ? getConfirmation : _props$getUserConfirm,\n    _props$hashType = props.hashType,\n    hashType = _props$hashType === undefined ? 'slash' : _props$hashType;\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\n  var _HashPathCoders$hashT = HashPathCoders[hashType],\n    encodePath = _HashPathCoders$hashT.encodePath,\n    decodePath = _HashPathCoders$hashT.decodePath;\n  var getDOMLocation = function getDOMLocation() {\n    var path = decodePath(getHashPath());\n    warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\n    if (basename) path = stripBasename(path, basename);\n    return createLocation(path);\n  };\n  var transitionManager = createTransitionManager();\n  var setState = function setState(nextState) {\n    _extends(history, nextState);\n    history.length = globalHistory.length;\n    transitionManager.notifyListeners(history.location, history.action);\n  };\n  var forceNextPop = false;\n  var ignorePath = null;\n  var handleHashChange = function handleHashChange() {\n    var path = getHashPath();\n    var encodedPath = encodePath(path);\n    if (path !== encodedPath) {\n      // Ensure we always have a properly-encoded hash.\n      replaceHashPath(encodedPath);\n    } else {\n      var location = getDOMLocation();\n      var prevLocation = history.location;\n      if (!forceNextPop && locationsAreEqual(prevLocation, location)) return; // A hashchange doesn't always == location change.\n\n      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.\n\n      ignorePath = null;\n      handlePop(location);\n    }\n  };\n  var handlePop = function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({\n            action: action,\n            location: location\n          });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  };\n  var revertPop = function revertPop(fromLocation) {\n    var toLocation = history.location;\n\n    // TODO: We could probably make this more reliable by\n    // keeping a list of paths we've seen in sessionStorage.\n    // Instead, we just default to 0 for paths we don't know.\n\n    var toIndex = allPaths.lastIndexOf(createPath(toLocation));\n    if (toIndex === -1) toIndex = 0;\n    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));\n    if (fromIndex === -1) fromIndex = 0;\n    var delta = toIndex - fromIndex;\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  };\n\n  // Ensure the hash is encoded properly before doing anything else.\n  var path = getHashPath();\n  var encodedPath = encodePath(path);\n  if (path !== encodedPath) replaceHashPath(encodedPath);\n  var initialLocation = getDOMLocation();\n  var allPaths = [createPath(initialLocation)];\n\n  // Public interface\n\n  var createHref = function createHref(location) {\n    return '#' + encodePath(basename + createPath(location));\n  };\n  var push = function push(path, state) {\n    warning(state === undefined, 'Hash history cannot push state; it is ignored');\n    var action = 'PUSH';\n    var location = createLocation(path, undefined, undefined, history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a PUSH, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        pushHashPath(encodedPath);\n        var prevIndex = allPaths.lastIndexOf(createPath(history.location));\n        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\n        nextPaths.push(path);\n        allPaths = nextPaths;\n        setState({\n          action: action,\n          location: location\n        });\n      } else {\n        warning(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');\n        setState();\n      }\n    });\n  };\n  var replace = function replace(path, state) {\n    warning(state === undefined, 'Hash history cannot replace state; it is ignored');\n    var action = 'REPLACE';\n    var location = createLocation(path, undefined, undefined, history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a REPLACE, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        replaceHashPath(encodedPath);\n      }\n      var prevIndex = allPaths.indexOf(createPath(history.location));\n      if (prevIndex !== -1) allPaths[prevIndex] = path;\n      setState({\n        action: action,\n        location: location\n      });\n    });\n  };\n  var go = function go(n) {\n    warning(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');\n    globalHistory.go(n);\n  };\n  var goBack = function goBack() {\n    return go(-1);\n  };\n  var goForward = function goForward() {\n    return go(1);\n  };\n  var listenerCount = 0;\n  var checkDOMListeners = function checkDOMListeners(delta) {\n    listenerCount += delta;\n    if (listenerCount === 1) {\n      addEventListener(window, HashChangeEvent, handleHashChange);\n    } else if (listenerCount === 0) {\n      removeEventListener(window, HashChangeEvent, handleHashChange);\n    }\n  };\n  var isBlocked = false;\n  var block = function block() {\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var unblock = transitionManager.setPrompt(prompt);\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n      return unblock();\n    };\n  };\n  var listen = function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  };\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n  return history;\n};\nexport default createHashHistory;","map":{"version":3,"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","warning","invariant","createLocation","locationsAreEqual","addLeadingSlash","stripLeadingSlash","stripTrailingSlash","hasBasename","stripBasename","createPath","createTransitionManager","canUseDOM","addEventListener","removeEventListener","getConfirmation","supportsGoWithoutReloadUsingHash","HashChangeEvent","HashPathCoders","hashbang","encodePath","path","charAt","decodePath","substr","noslash","slash","getHashPath","href","window","location","hashIndex","indexOf","substring","pushHashPath","hash","replaceHashPath","replace","slice","createHashHistory","props","undefined","globalHistory","history","canGoWithoutReload","_props$getUserConfirm","getUserConfirmation","_props$hashType","hashType","basename","_HashPathCoders$hashT","getDOMLocation","transitionManager","setState","nextState","notifyListeners","action","forceNextPop","ignorePath","handleHashChange","encodedPath","prevLocation","handlePop","confirmTransitionTo","ok","revertPop","fromLocation","toLocation","toIndex","allPaths","lastIndexOf","fromIndex","delta","go","initialLocation","createHref","push","state","hashChanged","prevIndex","nextPaths","n","goBack","goForward","listenerCount","checkDOMListeners","isBlocked","block","prompt","unblock","setPrompt","listen","listener","unlisten","appendListener"],"sources":["C:/Users/ashut/OneDrive/Desktop/UPGRAD/React-Project/BookMovieApp/BookMovieApp/node_modules/history/es/createHashHistory.js"],"sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nimport warning from 'warning';\r\nimport invariant from 'invariant';\r\nimport { createLocation, locationsAreEqual } from './LocationUtils';\r\nimport { addLeadingSlash, stripLeadingSlash, stripTrailingSlash, hasBasename, stripBasename, createPath } from './PathUtils';\r\nimport createTransitionManager from './createTransitionManager';\r\nimport { canUseDOM, addEventListener, removeEventListener, getConfirmation, supportsGoWithoutReloadUsingHash } from './DOMUtils';\r\n\r\nvar HashChangeEvent = 'hashchange';\r\n\r\nvar HashPathCoders = {\r\n  hashbang: {\r\n    encodePath: function encodePath(path) {\r\n      return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);\r\n    },\r\n    decodePath: function decodePath(path) {\r\n      return path.charAt(0) === '!' ? path.substr(1) : path;\r\n    }\r\n  },\r\n  noslash: {\r\n    encodePath: stripLeadingSlash,\r\n    decodePath: addLeadingSlash\r\n  },\r\n  slash: {\r\n    encodePath: addLeadingSlash,\r\n    decodePath: addLeadingSlash\r\n  }\r\n};\r\n\r\nvar getHashPath = function getHashPath() {\r\n  // We can't use window.location.hash here because it's not\r\n  // consistent across browsers - Firefox will pre-decode it!\r\n  var href = window.location.href;\r\n  var hashIndex = href.indexOf('#');\r\n  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);\r\n};\r\n\r\nvar pushHashPath = function pushHashPath(path) {\r\n  return window.location.hash = path;\r\n};\r\n\r\nvar replaceHashPath = function replaceHashPath(path) {\r\n  var hashIndex = window.location.href.indexOf('#');\r\n\r\n  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);\r\n};\r\n\r\nvar createHashHistory = function createHashHistory() {\r\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n\r\n  invariant(canUseDOM, 'Hash history needs a DOM');\r\n\r\n  var globalHistory = window.history;\r\n  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();\r\n\r\n  var _props$getUserConfirm = props.getUserConfirmation,\r\n      getUserConfirmation = _props$getUserConfirm === undefined ? getConfirmation : _props$getUserConfirm,\r\n      _props$hashType = props.hashType,\r\n      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;\r\n\r\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\r\n\r\n  var _HashPathCoders$hashT = HashPathCoders[hashType],\r\n      encodePath = _HashPathCoders$hashT.encodePath,\r\n      decodePath = _HashPathCoders$hashT.decodePath;\r\n\r\n\r\n  var getDOMLocation = function getDOMLocation() {\r\n    var path = decodePath(getHashPath());\r\n\r\n    warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\r\n\r\n    if (basename) path = stripBasename(path, basename);\r\n\r\n    return createLocation(path);\r\n  };\r\n\r\n  var transitionManager = createTransitionManager();\r\n\r\n  var setState = function setState(nextState) {\r\n    _extends(history, nextState);\r\n\r\n    history.length = globalHistory.length;\r\n\r\n    transitionManager.notifyListeners(history.location, history.action);\r\n  };\r\n\r\n  var forceNextPop = false;\r\n  var ignorePath = null;\r\n\r\n  var handleHashChange = function handleHashChange() {\r\n    var path = getHashPath();\r\n    var encodedPath = encodePath(path);\r\n\r\n    if (path !== encodedPath) {\r\n      // Ensure we always have a properly-encoded hash.\r\n      replaceHashPath(encodedPath);\r\n    } else {\r\n      var location = getDOMLocation();\r\n      var prevLocation = history.location;\r\n\r\n      if (!forceNextPop && locationsAreEqual(prevLocation, location)) return; // A hashchange doesn't always == location change.\r\n\r\n      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.\r\n\r\n      ignorePath = null;\r\n\r\n      handlePop(location);\r\n    }\r\n  };\r\n\r\n  var handlePop = function handlePop(location) {\r\n    if (forceNextPop) {\r\n      forceNextPop = false;\r\n      setState();\r\n    } else {\r\n      var action = 'POP';\r\n\r\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\r\n        if (ok) {\r\n          setState({ action: action, location: location });\r\n        } else {\r\n          revertPop(location);\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  var revertPop = function revertPop(fromLocation) {\r\n    var toLocation = history.location;\r\n\r\n    // TODO: We could probably make this more reliable by\r\n    // keeping a list of paths we've seen in sessionStorage.\r\n    // Instead, we just default to 0 for paths we don't know.\r\n\r\n    var toIndex = allPaths.lastIndexOf(createPath(toLocation));\r\n\r\n    if (toIndex === -1) toIndex = 0;\r\n\r\n    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));\r\n\r\n    if (fromIndex === -1) fromIndex = 0;\r\n\r\n    var delta = toIndex - fromIndex;\r\n\r\n    if (delta) {\r\n      forceNextPop = true;\r\n      go(delta);\r\n    }\r\n  };\r\n\r\n  // Ensure the hash is encoded properly before doing anything else.\r\n  var path = getHashPath();\r\n  var encodedPath = encodePath(path);\r\n\r\n  if (path !== encodedPath) replaceHashPath(encodedPath);\r\n\r\n  var initialLocation = getDOMLocation();\r\n  var allPaths = [createPath(initialLocation)];\r\n\r\n  // Public interface\r\n\r\n  var createHref = function createHref(location) {\r\n    return '#' + encodePath(basename + createPath(location));\r\n  };\r\n\r\n  var push = function push(path, state) {\r\n    warning(state === undefined, 'Hash history cannot push state; it is ignored');\r\n\r\n    var action = 'PUSH';\r\n    var location = createLocation(path, undefined, undefined, history.location);\r\n\r\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\r\n      if (!ok) return;\r\n\r\n      var path = createPath(location);\r\n      var encodedPath = encodePath(basename + path);\r\n      var hashChanged = getHashPath() !== encodedPath;\r\n\r\n      if (hashChanged) {\r\n        // We cannot tell if a hashchange was caused by a PUSH, so we'd\r\n        // rather setState here and ignore the hashchange. The caveat here\r\n        // is that other hash histories in the page will consider it a POP.\r\n        ignorePath = path;\r\n        pushHashPath(encodedPath);\r\n\r\n        var prevIndex = allPaths.lastIndexOf(createPath(history.location));\r\n        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\r\n\r\n        nextPaths.push(path);\r\n        allPaths = nextPaths;\r\n\r\n        setState({ action: action, location: location });\r\n      } else {\r\n        warning(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');\r\n\r\n        setState();\r\n      }\r\n    });\r\n  };\r\n\r\n  var replace = function replace(path, state) {\r\n    warning(state === undefined, 'Hash history cannot replace state; it is ignored');\r\n\r\n    var action = 'REPLACE';\r\n    var location = createLocation(path, undefined, undefined, history.location);\r\n\r\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\r\n      if (!ok) return;\r\n\r\n      var path = createPath(location);\r\n      var encodedPath = encodePath(basename + path);\r\n      var hashChanged = getHashPath() !== encodedPath;\r\n\r\n      if (hashChanged) {\r\n        // We cannot tell if a hashchange was caused by a REPLACE, so we'd\r\n        // rather setState here and ignore the hashchange. The caveat here\r\n        // is that other hash histories in the page will consider it a POP.\r\n        ignorePath = path;\r\n        replaceHashPath(encodedPath);\r\n      }\r\n\r\n      var prevIndex = allPaths.indexOf(createPath(history.location));\r\n\r\n      if (prevIndex !== -1) allPaths[prevIndex] = path;\r\n\r\n      setState({ action: action, location: location });\r\n    });\r\n  };\r\n\r\n  var go = function go(n) {\r\n    warning(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');\r\n\r\n    globalHistory.go(n);\r\n  };\r\n\r\n  var goBack = function goBack() {\r\n    return go(-1);\r\n  };\r\n\r\n  var goForward = function goForward() {\r\n    return go(1);\r\n  };\r\n\r\n  var listenerCount = 0;\r\n\r\n  var checkDOMListeners = function checkDOMListeners(delta) {\r\n    listenerCount += delta;\r\n\r\n    if (listenerCount === 1) {\r\n      addEventListener(window, HashChangeEvent, handleHashChange);\r\n    } else if (listenerCount === 0) {\r\n      removeEventListener(window, HashChangeEvent, handleHashChange);\r\n    }\r\n  };\r\n\r\n  var isBlocked = false;\r\n\r\n  var block = function block() {\r\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\r\n\r\n    var unblock = transitionManager.setPrompt(prompt);\r\n\r\n    if (!isBlocked) {\r\n      checkDOMListeners(1);\r\n      isBlocked = true;\r\n    }\r\n\r\n    return function () {\r\n      if (isBlocked) {\r\n        isBlocked = false;\r\n        checkDOMListeners(-1);\r\n      }\r\n\r\n      return unblock();\r\n    };\r\n  };\r\n\r\n  var listen = function listen(listener) {\r\n    var unlisten = transitionManager.appendListener(listener);\r\n    checkDOMListeners(1);\r\n\r\n    return function () {\r\n      checkDOMListeners(-1);\r\n      unlisten();\r\n    };\r\n  };\r\n\r\n  var history = {\r\n    length: globalHistory.length,\r\n    action: 'POP',\r\n    location: initialLocation,\r\n    createHref: createHref,\r\n    push: push,\r\n    replace: replace,\r\n    go: go,\r\n    goBack: goBack,\r\n    goForward: goForward,\r\n    block: block,\r\n    listen: listen\r\n  };\r\n\r\n  return history;\r\n};\r\n\r\nexport default createHashHistory;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}